import { google } from 'googleapis';
import type { AgentPlan, Workstream, Step } from '@/lib/types';

interface CalendarConfig {
  clientId?: string;
  clientSecret?: string;
  redirectUri?: string;
}

interface CalendarEvent {
  summary: string;
  description?: string;
  start: {
    dateTime: string;
    timeZone: string;
  };
  end: {
    dateTime: string;
    timeZone: string;
  };
  reminders?: {
    useDefault: boolean;
    overrides?: Array<{
      method: string;
      minutes: number;
    }>;
  };
}

class GoogleCalendarClient {
  private config: CalendarConfig;
  private oauth2Client: any;

  constructor(config?: CalendarConfig) {
    this.config = {
      clientId: config?.clientId || process.env.GOOGLE_CALENDAR_CLIENT_ID,
      clientSecret: config?.clientSecret || process.env.GOOGLE_CALENDAR_CLIENT_SECRET,
      redirectUri: config?.redirectUri || process.env.GOOGLE_CALENDAR_REDIRECT_URI || 'http://localhost:3001/api/calendar/callback',
    };
  }

  async initialize(): Promise<void> {
    if (!this.config.clientId || !this.config.clientSecret) {
      throw new Error('Google Calendar credentials are required. Please set GOOGLE_CALENDAR_CLIENT_ID and GOOGLE_CALENDAR_CLIENT_SECRET environment variables.');
    }

    try {
      this.oauth2Client = new google.auth.OAuth2(
        this.config.clientId,
        this.config.clientSecret,
        this.config.redirectUri
      );

      // For demo purposes, we'll create a simple calendar URL instead of full OAuth
      console.log('Google Calendar client initialized');
    } catch (error) {
      console.error('Failed to initialize Google Calendar client:', error);
      throw new Error(`Calendar initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // For hackathon demo: Generate Google Calendar URLs instead of OAuth
  generateCalendarUrl(event: CalendarEvent): string {
    const startDate = new Date(event.start.dateTime);
    const endDate = new Date(event.end.dateTime);
    
    // Format dates for Google Calendar URL (YYYYMMDDTHHMMSSZ)
    const formatDate = (date: Date) => {
      return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
    };

    const params = new URLSearchParams({
      action: 'TEMPLATE',
      text: event.summary,
      dates: `${formatDate(startDate)}/${formatDate(endDate)}`,
      details: event.description || '',
      trp: 'false' // Don't show in popup
    });

    return `https://calendar.google.com/calendar/render?${params.toString()}`;
  }

  async createEvent(event: CalendarEvent): Promise<{ success: boolean; url?: string; error?: string }> {
    try {
      // For demo: return calendar URL instead of creating actual event
      const calendarUrl = this.generateCalendarUrl(event);
      
      console.log('Calendar event URL generated:', calendarUrl);
      
      return {
        success: true,
        url: calendarUrl
      };
    } catch (error) {
      console.error('Failed to create calendar event:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  async createEventsFromPlan(plan: AgentPlan): Promise<{ success: boolean; events: Array<{ title: string; url?: string; error?: string }> }> {
    try {
      const events: Array<{ title: string; url?: string; error?: string }> = [];
      const timeZone = 'America/New_York'; // Default timezone

      // Create event for main deadline
      if (plan.userContext.deadline) {
        const mainDeadline = new Date(plan.userContext.deadline);
        // Set to 9 AM on deadline day
        mainDeadline.setHours(9, 0, 0, 0);
        const mainEndTime = new Date(mainDeadline);
        mainEndTime.setHours(10, 0, 0, 0);

        const mainEvent: CalendarEvent = {
          summary: `${plan.userContext.visaType || 'Immigration'} Application Deadline`,
          description: `Final deadline for your ${plan.userContext.visaType || 'immigration'} application.\n\nPlan: ${plan.planSummary.headline}\n\nGenerated by Bureaucracy Navigator`,
          start: {
            dateTime: mainDeadline.toISOString(),
            timeZone
          },
          end: {
            dateTime: mainEndTime.toISOString(),
            timeZone
          },
          reminders: {
            useDefault: false,
            overrides: [
              { method: 'email', minutes: 24 * 60 }, // 1 day before
              { method: 'popup', minutes: 60 } // 1 hour before
            ]
          }
        };

        const result = await this.createEvent(mainEvent);
        events.push({
          title: mainEvent.summary,
          url: result.url,
          error: result.error
        });
      }

      // Create events for each workstream step with deadlines
      for (const workstream of plan.workstreams || []) {
        for (const step of workstream.steps || []) {
          if (step.deadline) {
            const stepDeadline = new Date(step.deadline);
            stepDeadline.setHours(14, 0, 0, 0); // 2 PM
            const stepEndTime = new Date(stepDeadline);
            stepEndTime.setHours(15, 0, 0, 0); // 3 PM

            const stepEvent: CalendarEvent = {
              summary: `Immigration: ${step.name}`,
              description: `${workstream.title} - ${step.name}\n\n` +
                         `${step.instructions ? 'Instructions:\n' + step.instructions.slice(0, 3).map((inst, i) => `${i + 1}. ${inst}`).join('\n') : ''}` +
                         `\n\nEstimated time: ${step.estimatedTime || 'Not specified'}\n\nGenerated by Bureaucracy Navigator`,
              start: {
                dateTime: stepDeadline.toISOString(),
                timeZone
              },
              end: {
                dateTime: stepEndTime.toISOString(),
                timeZone
              },
              reminders: {
                useDefault: false,
                overrides: [
                  { method: 'email', minutes: 24 * 60 }, // 1 day before
                  { method: 'popup', minutes: 30 } // 30 minutes before
                ]
              }
            };

            const result = await this.createEvent(stepEvent);
            events.push({
              title: stepEvent.summary,
              url: result.url,
              error: result.error
            });
          }
        }
      }

      // Create events for timeline items
      for (const timelineItem of plan.timeline || []) {
        const timelineDate = new Date(timelineItem.dueDate);
        timelineDate.setHours(12, 0, 0, 0); // Noon
        const timelineEndTime = new Date(timelineDate);
        timelineEndTime.setHours(13, 0, 0, 0); // 1 PM

        const timelineEvent: CalendarEvent = {
          summary: `Immigration: ${timelineItem.title}`,
          description: `${timelineItem.description || ''}\n\nGenerated by Bureaucracy Navigator`,
          start: {
            dateTime: timelineDate.toISOString(),
            timeZone
          },
          end: {
            dateTime: timelineEndTime.toISOString(),
            timeZone
          },
          reminders: {
            useDefault: false,
            overrides: [
              { method: 'email', minutes: 24 * 60 }, // 1 day before
            ]
          }
        };

        const result = await this.createEvent(timelineEvent);
        events.push({
          title: timelineEvent.summary,
          url: result.url,
          error: result.error
        });
      }

      return {
        success: true,
        events
      };
    } catch (error) {
      console.error('Failed to create events from plan:', error);
      return {
        success: false,
        events: [{
          title: 'Error',
          error: error instanceof Error ? error.message : 'Unknown error'
        }]
      };
    }
  }

  async testConnection(): Promise<{ success: boolean; error?: string }> {
    try {
      await this.initialize();
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
}

export const googleCalendarClient = new GoogleCalendarClient();